# ZSH Theme - Preview: http://cl.ly/f701d00760f8059e06dc
# Thanks to gallifrey, upon whose theme this is based

function prompt_yut23_setup {
  local exit_code="%(?..%{$fg_bold[red]%}%?%{$reset_color%})"
  prompt_opts=(cr sp percent subst)

  # different color for ssh session
  local user="%{$fg[green]%}%n%{$reset_color%}"
  if [[ -n "${SSH_CLIENT+1}" ]]; then
    # ssh
    local host="%{$fg[cyan]%}@$HOSTNAME%{$reset_color%}"
  else
    # local
    local host="%{$fg[green]%}@$HOSTNAME%{$reset_color%}"
  fi
  local current_dir="%{$fg[yellow]%}%~%{$reset_color%}"
  local git_prompt='$(_my_git_prompt_info)'
  local -a groups
  groups=($(id -G))
  # check if gid 0 is present in the groups array
  (( ${+groups[(r)0]} )) && prompt_symbol='#' || prompt_symbol='\$'
  if (( SHLVL > 1 )); then
    prompt_symbol="$SHLVL$prompt_symbol"
  fi
  local throttled=''
  if [[ -e "/sys/fs/cgroup/cpu/user.slice/user-$UID.slice/cpu.stat" ]]; then
    throttled='$(_check_throttled)'
  fi

  PS1="
${user}${host}${throttled} ${current_dir} ${git_prompt}
${prompt_symbol} "
  RPS1="%{$fg[green]%}\$(_virtualenv_info)%{$reset_color%}${exit_code}"

  zle -N zle-keymap-select
  zle -N zle-line-finish
}

function _virtualenv_info {
  if [[ -n "$CONDA_DEFAULT_ENV" ]]; then
    echo "($CONDA_DEFAULT_ENV) "
  elif [[ -n "$VIRTUAL_ENV" ]] then
    echo "%{$fg[blue]%}(${VIRTUAL_ENV:t}) "
  fi
}

function _check_throttled {
  # read cpu.stat into an associative array
  local -A cpu_stat
  cpu_stat=(${(@)$(<"/sys/fs/cgroup/cpu/user.slice/user-$UID.slice/cpu.stat")})
  if [[ $cpu_stat[nr_throttled] -gt 0 ]]; then
    echo " %{$fg_bold[red]%}throttled%{$reset_color%}"
  fi
}

function zle-keymap-select {
  zle reset-prompt
  [[ ($TERM =~ "xterm.*" || $TERM =~ "screen.*") && $KEYMAP == 'vicmd' ]] && echo -n '[1 q' || echo -n '[5 q'
}

function zle-line-finish {
  [[ $TERM =~ "xterm.*" || $TERM =~ "screen.*" ]] && echo -n '[5 q'
}

function _my_git_prompt_info() {
  local ref index git_status
  local symbol_untracked="%%"
  local symbol_added="+"
  local symbol_modified="*"
  local symbol_renamed="~"
  local symbol_deleted="!"
  local symbol_unmerged="?"
  local symbol_ahead="â†‘"
  local symbol_behind="â†“"
  local symbol_diverged="â†•"

  ref=$(git symbolic-ref HEAD 2> /dev/null) || return
  # Modified to use pure zsh functions instead of grep
  index=$(command git status --porcelain -b 2> /dev/null)
  git_status=""
  if [[ $index =~ $'\n''\?\? ' ]]; then
    git_status="$symbol_untracked$git_status"
  fi
  if [[ $index =~ $'\n[AM]  ' ]]; then
    git_status="$symbol_added$git_status"
  fi
  if [[ $index =~ $'\n[ AR]M ' ]]; then
    git_status="$symbol_modified$git_status"
  fi
  if [[ $index =~ $'\nR[ M] ' ]]; then
    git_status="$symbol_renamed$git_status"
  fi
  if [[ $index =~ $'\n[ A]D ' ]]; then
    git_status="$symbol_deleted$git_status"
  elif [[ $index =~ $'\nD  ' ]]; then
    git_status="$symbol_deleted$git_status"
  fi
  if [[ $index =~ $'\nUU ' ]]; then
    git_status="$symbol_unmerged$git_status"
  fi
  if [[ $index =~ $'^## .*ahead' ]]; then
    git_status="$symbol_ahead$git_status"
  fi
  if [[ $index =~ $'^## .*behind' ]]; then
    git_status="$symbol_behind$git_status"
  fi
  if [[ $index =~ $'^## .*diverged' ]]; then
    git_status="$symbol_diverged$git_status"
  fi
  if [[ -n $git_status ]]; then
    if [[ $git_status =~ [%+*~\!?] ]]; then
      echo "%{$terminfo[bold]$fg[red]%}(${ref#refs/heads/} $git_status)%{$reset_color%}"
    else
      echo "%{$terminfo[bold]$fg[yellow]%}(${ref#refs/heads/} $git_status)%{$reset_color%}"
    fi
  else
    echo "%{$terminfo[bold]$fg[green]%}(${ref#refs/heads/})%{$reset_color%}"
  fi
}

# vim: filetype=zsh
